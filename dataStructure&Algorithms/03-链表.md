# 数据结构和算法笔记 03-链表（Linked list）

通过“指针”将一组零散的内存块（结点 Node）串联起来使用，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址（后继指针 next）

- 优点: 插入和删除操作高效，时间复杂度为 O(1)
- 缺点:
  - 数据访问性能没有数组好，随机访问第 k 个元素，时间复杂度为 O(n)
  - 和数组相比，内存空间消耗大，因为每个节点都需要额外存储后继指针

## 1. 链表的种类

### 1.1 单链表

- 每个节点只包含一个指针，即后继指针。
- 两个特殊的节点：头结点（用来记录链表的基地址），尾结点（指向一个空地址 NULL，表示这是链表上最后一个结点）

### 1.2 循环链表

一种特殊的单链表：尾结点指针指向链表的头结点

优点：从链尾到链头比较方便（处理的数据具有环型结构特点时，适合采用循环链表）

### 1.3 双向链表

每个结点包含两个指针：后继指针 next 和 前驱指针 prev（首节点的前驱指针 prev 和尾节点的后继指针指向空地址）

特点：比单链表占用更多的内存空间，但支持双向遍历，灵活性高

### 1.4 双向循环链表

首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点

## 2. 几种链表操作复杂度对比

1. 删除结点中“值等于某个给定值”的结点

   删除操作时间复杂度是 O(1)，遍历查找对应的时间复杂度为 O(n)

2. 删除给定指针指向的结点

   已找到要删除的结点，但删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，需要遍历。此情况下单链表时间复杂度为 O(n) ，双向链表时间复杂度为 O(1)

3. 在链表的指定结点前插入一个结点

   单链表时间复杂度为 O(n) ，双向链表时间复杂度为 O(1)

4. 有序链表查询操作

   双向链表，可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定往前还是往后查找，平均只需要查找一半数据

## 3. 数组和链表性优劣对比

1. 插入、删除和随机访问的时间复杂度对比：

   - 数组：插入、删除的时间复杂度是 O(n)，随机访问的时间复杂度是 O(1)。
   - 链表：插入、删除的时间复杂度是 O(1)，随机访问的时间复杂端是 O(n)。

2. 内存空间对比：

   - 数组：需要使用连续内存空间，大小固定，如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，出现不够用的情况，需进行扩容时需要进行数据复制，非常费时
   - 链表：
     - 相对数组更消耗内存，因为需要额外的空间存储指针信息
     - 进行频繁的插入和删除操作时，会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，还可能会造成频繁的 GC（自动垃圾回收器）操作
     - 本身无大小限制，支持动态扩容

3. 缓存：

   - 数组：因为使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，访问效率更高
   - 链表：内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

## 4. 设计思想

时空替换思想：“用空间换时间” 与 “用时间换空间”

当内存空间充足的时候，如果更加追求代码的执行速度，可以选择空间复杂度相对较高、但时间复杂度相对低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这时，就要反过来用时间换空间的设计思路。
